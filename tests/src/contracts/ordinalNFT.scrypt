
contract OrdinalNFT {
  @state bool isOrdinalNFT;
  constructor() {
    this.isOrdinalNFT = true;
  }
  function buildNFTStateOutput() : bytes {
    bytes stateScript = OrdinalNFT.removeInsciption(this.getStateScript());
    return Utils.buildOutput(stateScript, 1);
  }
  function buildMintNFTOutput(bytes script, bytes content, bytes contentType) : bytes {
    bytes part1 = OrdinalNFT.createInsciption(content, contentType);
    bytes part2 = OrdinalNFT.removeInsciption(script);
    return Utils.buildOutput(part1 + part2, 1);
  }
  static function skipBytes(bytes b) : int {
    int len = 0;
    int ret = 0;
    int header = unpack(b[0 : 1]);
    if(header < 0x4c) {
        len = header;
        ret = 1 + len;
      } else if(header == 0x4c) {
        len = Utils.fromLEUnsigned(b[1 : 2]);
        ret = 1 + 1 + len;
      } else if(header == 0x4d) {
        len = Utils.fromLEUnsigned(b[1 : 3]);
        ret = 1 + 2 + len;
      } else if(header == 0x4e) {
        len = Utils.fromLEUnsigned(b[1 : 5]);
        ret = 1 + 4 + len;
      } else {
        ret = -1;
      }
    return ret;
  }
  static function isP2PKHOrdinal(bytes script) : bool {
    return (len(script) > 25 && OrdinalNFT.isP2PKH(script[0 : 25]) && OrdinalNFT.sizeOfOrdinal(script[25 : len(script)]) > 0);
  }
  static function isP2PKH(bytes script) : bool {
    return (len(script) == 25 && script[0 : 3] == b'76a914' && script[23 : len(script)] == b'88ac');
  }
  static function removeInsciption(bytes scriptCode) : bytes {
    int inscriptLen = OrdinalNFT.sizeOfOrdinal(scriptCode);
    if(inscriptLen > 0) {
        scriptCode = scriptCode[inscriptLen : len(scriptCode)];
      }
    return scriptCode;
  }
  static function getInsciptionScript(bytes scriptCode) : bytes {
    int inscriptLen = OrdinalNFT.sizeOfOrdinal(scriptCode);
    bytes ret = b'';
    if(inscriptLen > 0) {
        ret = scriptCode[0 : inscriptLen];
      }
    return ret;
  }
  static function sizeOfOrdinal(bytes script) : int {
    int ret = -1;
    int pos = 0;
    if(len(script) >= 11 && script[pos : 7] == b'0063036f726451') {
        pos += 7;
        int contentTypeLen = OrdinalNFT.skipBytes(script[pos : len(script)]);
        if(contentTypeLen > 0) {
          pos += contentTypeLen;
          if(script[pos : pos + 1] == OpCode.OP_0) {
            pos += 1;
            int contentLen = OrdinalNFT.skipBytes(script[pos : len(script)]);
            if(contentLen > 0) {
              pos += contentLen;
              if(script[pos : pos + 1] == OpCode.OP_ENDIF) {
                pos += 1;
                ret = pos;
              }
            }
          }
        }
      }
    return ret;
  }
  static function createInsciption(bytes content, bytes contentType) : bytes {
    return (OpCode.OP_FALSE + OpCode.OP_IF + VarIntWriter.writeBytes("ord") + OpCode.OP_1 + VarIntWriter.writeBytes(contentType) + OpCode.OP_FALSE + VarIntWriter.writeBytes(content) + OpCode.OP_ENDIF);
  }
  public function hide() {
    require(false);
  }
    function buildStateOutput(int amount): bytes {
      bytes script = this.getStateScript();
      return Utils.buildOutput(script, amount);
    }
}